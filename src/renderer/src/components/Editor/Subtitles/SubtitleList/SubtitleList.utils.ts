import { Subtitle } from '@renderer/store/store'
import { SubtitleFormat } from './SubtitleList.types'
import Konva from 'konva'

export function generateSRT(subtitles: Subtitle[]): string {
  return subtitles
    .map((subtitle, index) => {
      const start = formatTime(subtitle.start, SubtitleFormat.SRT)
      const end = formatTime(subtitle.end, SubtitleFormat.SRT)
      return `${index + 1}\n${start} --> ${end}\n${subtitle.text}\n`
    })
    .join('\n')
}

export function generateVTT(subtitles: Subtitle[]): string {
  return (
    'WEBVTT\n\n' +
    subtitles
      .map((subtitle) => {
        const start = formatTime(subtitle.start, SubtitleFormat.VTT)
        const end = formatTime(subtitle.end, SubtitleFormat.VTT)
        return `${start} --> ${end}\n${subtitle.text}\n`
      })
      .join('\n')
  )
}

export function generateTXT(subtitles: Subtitle[]): string {
  return subtitles.map((subtitle) => `${subtitle.text}\n`).join('')
}

export function downloadSubtitles(subtitles: string, format: SubtitleFormat): void {
  const blob = new Blob([subtitles], { type: 'text/plain' })
  const url = URL.createObjectURL(blob)

  const a = document.createElement('a')
  a.href = url
  a.download = `subtitles.${format}`
  document.body.appendChild(a)
  a.click()

  // Cleanup
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}

export function formatTime(seconds: number, format?: SubtitleFormat): string {
  const formattedTime = new Date(seconds * 1000).toISOString()
  if (format === SubtitleFormat.SRT) return formattedTime.slice(11, -1).replace('.', ',')
  if (format === SubtitleFormat.VTT) return formattedTime.slice(11, -1)
  if (format === SubtitleFormat.ASS) {
    const totalSeconds = Math.floor(seconds)
    const deciseconds = Math.floor((seconds - totalSeconds) * 100)
    const hours = Math.floor(totalSeconds / 3600)
    const remainingSeconds = totalSeconds % 3600
    const minutes = Math.floor(remainingSeconds / 60)
    const secs = remainingSeconds % 60
    const pad = (num: number, size: number): string => {
      const s = '0' + num
      return s.slice(s.length - size)
    }
    return `${hours}:${pad(minutes, 2)}:${pad(secs, 2)}.${pad(deciseconds, 2)}`
  }
  // UI display format e.g. 01:12.5
  const uiDisplayFormat = formattedTime.slice(11, -2)
  const hoursEndIndex = uiDisplayFormat.indexOf(':')
  const hours = parseInt(uiDisplayFormat.slice(0, hoursEndIndex))
  return hours > 0 ? uiDisplayFormat : uiDisplayFormat.slice(hoursEndIndex + 1)
}

export function isSubtitlePlaying(currentTime: number, start: number, end: number): boolean {
  return (
    +currentTime?.toFixed(2) >= +start?.toFixed(2) && +currentTime?.toFixed(2) < +end?.toFixed(2)
  )
}

export function generateASS(
  canvasWidth: number,
  canvasHeight: number,
  styleProps: Konva.TextConfig,
  subtitles: Subtitle[]
): string {
  const { fontSize, rotation, x, y } = styleProps
  const konvaTextNode = getHeadlessKonvaTextNode(styleProps, canvasWidth, canvasHeight)

  return `[Script Info]
; Script generated by Subtify
Title: Sample Subtitle
Original Script: User
ScriptType: v4.00+
Collisions: Normal
PlayDepth: 0
LayoutResX: ${canvasWidth}
LayoutResY: ${canvasHeight}
PlayResX: ${canvasWidth}
PlayResY: ${canvasHeight}

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default, Arial, ${fontSize}, &H00FFFFFF, &H000000FF, &H00000000, &HFF000000, 0, 0, 0, 0, 100, 100, 0, ${-rotation!}, 3, 1, 0, 2, 0, 0, 0, 1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
${subtitles
  .map((subtitle) => {
    const start = formatTime(subtitle.start, SubtitleFormat.ASS)
    const end = formatTime(subtitle.end, SubtitleFormat.ASS)
    // top left origin -----> centered origin
    konvaTextNode.setText(subtitle.text)
    const width = konvaTextNode.width()
    const height = konvaTextNode.height()
    const rotation = Konva.getAngle(konvaTextNode.rotation())
    const cosAngle = Math.cos(rotation)
    const sinAngle = Math.sin(rotation)
    const offsetX = width / 2
    const offsetY = height / 2
    const rotatedCenterX = x! + (offsetX * cosAngle - offsetY * sinAngle)
    const rotatedCenterY = y! + (offsetX * sinAngle + offsetY * cosAngle)

    return `Dialogue: 0,${start},${end},Default,,0,0,0,,{\\an5\\pos(${rotatedCenterX},${rotatedCenterY})}${konvaTextNode.textArr.map((t) => t.text).join('\\N')}`
  })
  .join('\n')}
`
}

export function getHeadlessKonvaTextNode(
  textProps: Konva.TextConfig,
  canvasWidth: number,
  canvasHeight: number
): Konva.Text {
  const container = document.createElement('div')
  container.id = 'headless-konva'
  const stage = new Konva.Stage({
    container,
    width: canvasWidth,
    height: canvasHeight
  })
  const layer = new Konva.Layer()
  const text = new Konva.Text(textProps)
  layer.add(text)
  stage.add(layer)
  return text
}

export function matchStrings(s1: string, s2: string): boolean {
  return (
    s1.trim().toLowerCase().includes(s2.trim().toLowerCase()) ||
    s2.trim().toLowerCase().includes(s1.trim().toLowerCase())
  )
}

export function generateUniqueId(): string {
  return Math.random().toString(16).slice(2)
}

export function hmsToSecondsOnly(str: string): number {
  const p = str.split(':')
  let s = 0
  let m = 1
  while (p.length > 0) {
    const part = p.pop()
    if (part === undefined) break
    s += parseFloat(part) * m
    m *= 60
  }
  return s
}
